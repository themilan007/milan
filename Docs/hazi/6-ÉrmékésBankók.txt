// Írj függvényt, ami visszaadja, egy paraméterként megadott egész számról, 
// hogy legkevesebb hány magyar érmével vagy bankóval kifejezni
// (Vegyük úgy, hogy még van 1 és 2 forintos.)
// PÉLDA: 
// Bemenet: 32 431
// Kimenet: 8 (mivel 20000 + 10000 + 2000 + 200 + 200 + 20 + 10 + 1 = 32 431)

//TÖMBÖK NÉLKÜL
int HowManyNotes(int num)
{
    int result = 0;

    result += num / 20000;   // Teszteljük 20 000-es bankóra
    num = num % 20000;

    result += num / 10000;   // Teszteljük 20 000-es bankóra
    num = num % 10000;

    // 1000-es 100-as és 10-es és 1-es nagyságrendet egy ciklusban:
    for (int m = 1000; m > 0; m /= 10)
    {
        int noteValue = 5 * m;      // 5000, 500, 50, 5
        result += num / noteValue; 
        num = num % noteValue;

        noteValue = 2 * m;          // 2000, 200, 20, 2
        result += num / noteValue;
        num = num % noteValue;

        noteValue = 1 * m;          // 1000, 100, 10, 1
        result += num / noteValue;
        num = num % noteValue;
    }

    return result;
}

// TÖMBBEL

readonly int[] notes =
	{20000,10000,5000,2000,1000,500,200,100,50,20,10,5,2,1};
// (a readonly nem kötelezõ)

int HowManyNotes(int num)
{
	int result = 0;
	for (int i = 0; i < notes.Length; i++)
	{
		int noteValue = notes[i];
		result += num / noteValue;
		num = num % noteValue;
	}

	// (foreach ciklus is használható for helyett)
	return result;
}


